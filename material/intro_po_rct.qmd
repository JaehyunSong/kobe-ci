---
title: "因果推論の考え方とランダム化比較試験"
toc: true
link-external-icon: true
link-external-newwindow: true
code-line-numbers: true
---

## スライド

<a href="../slide/intro_rct.html" class="btn btn-primary btn-sm" target="_blank" role="button"><i class="bi bi-window"></i> 新しいタブで開く</a>

```{=html}
<iframe class="slide-deck" src="../slide/intro_rct.html" width="100%" style="aspect-ratio: 16 / 9.2;"></iframe>
```

```{r}
#| include: false
knitr::opts_chunk$set(dev       = "ragg_png",
                      dpi       = 300,
                      fig.align = "center",
                      message   = FALSE,
                      warning   = FALSE)
```

## パッケージ

　通常、Rでのパッケージのインストールとアップーでとには`install.packages()`関数、読み込みには`library()`、または`require()`関数を使う。また、R公式レポジトリにないパッケージは{devtools}か{remote}パッケージを使う。これらの関数を使い分けることは面倒なので、本講義ではこれらの処理を統合した{pacman}パッケージを使用する。まずは、{pacman}パッケージをインストールする。

```{r}
#| eval: false
# NIIオンライン分析システムを利用する場合、導入済み
install.packages("pacman")
```

　パッケージを読み込む際、`pacman::p_load(読み込むパッケージ名)`を入力する。インストールされていない場合は、自動的にCRANからダウンロード&インストールした上で読み込んでくれるので便利だ[^pacman-update]。以下では本講義で使用するパッケージとして{tidyverse}、{summarytools}、{fastDummies}、{modelsummary}を読み込む。

[^pacman-update]: パッケージのアップデートには`pacman::p_update()`または`pacman::p_up()`関数を使う。`()`内に何も入力しない場合、全パッケージがアップデートされる。

```{r}
pacman::p_load(tidyverse, summarytools, fastDummies,
               modelsummary, broom)
```

　CRANでなく、GitHub上で公開されているパッケージを使う場合は`pacman::p_load_gh()`を使用する。`()`の中には`"ユーザー名/リポジトリ名"`を入力。たとえば、{BalanceR}の作成者のGitHubアカウント名は`JaehyunSong`であり、{BalanceR}のリポジトリ名は`BalanceR`だから、以下のように入力する。

```{r}
pacman::p_load_gh("JaehyunSong/BalanceR")
```

## データの読み込みと確認

　`.csv`形式のデータを読み込むには`read_csv()`関数を使用する。`()`内には読み込むファイルのパスを`"`で囲んで記入する。`read_csv()`関数はファイルの読み込み**のみ**の機能しか持たない。現在の作業環境内に読み込んだデータを格納するためには代入演算子`<-`を使う。ここでは`data`フォルダー内の`Day1_Data3.csv`を読み込み、`raw_df`という名のオブジェクトとしてく格納する。作業環境内のオブジェクトはRを再起動すると削除されるため、改めてパッケージ・データの読み込みが必要だ。

```{r}
raw_df <- read_csv("data/Day1_Data3.csv")
```

　オブジェクトの中身を出力するためにはオブジェクト名を入力する。

```{r}
raw_df
```

　表形式データの大きさ（行の列の数）の確認には`dim()`関数を使う。

```{r}
dim(raw_df)
```

　表形式データの場合、各列には名前が付いており、それぞれが一つの変数に該当する。これら変数名のみの出力には`names()`関数を使う。今回のデータだと、列の数が少ないこともあり、一画面に全列が表示されるが、数百列のデータとなると画面に収まらないので、変数名を確認しておくことを推奨する。

```{r}
names(raw_df)
```

## データハンドリングとパイプ演算子

　パイプ演算子には{magrittr}パッケージが提供する`%>%`とR 4.1から提供されるネイティブパイプ演算子の`|>`がある。現在の主流は古くから使われた`%>%`であるが、今後、`|>`が主流になると考えられるため、以下では`|>`を使用する。しかし、多くの場合、`|>`の代わりに`%>%`を使っても同じ結果が得られる。

　パイプ演算子はパイプ前のオブジェクトを、パイプ後の関数の**第一引数**として渡す単純な演算子だ。たとえば、列名を変更する関数は`rename()`であるが、使い方は`renames(データ名, 新しい列名 = 既存の列名, ...)`である。`raw_df`の`gender`列の名前を`female`に変更する場合は以下のように書く。

```{r}
rename(raw_df, female = gender)
```

　ここで第1引数が`raw_df`だが、パイプ演算子を使うと以下のようになり、人間にとって読みやすいコードになる。

```{r}
raw_df |>
  rename(female = gender)
```

　要するに、`X |> Y`は「`X`（の結果）を使って`Y`を行う」ことを意味する。

　続いて、変数のリコーディングをしてみよう。`x`の値が`"A"`なら1、それ以外は0のように、戻り値が2種類の場合のリコーディングには`if_else()`を使用する。書き方は以下の通りだ。

```{r}
#| eval: false
if_else(条件式, 条件が満たされる場合の戻り値, 条件が満たされない場合の戻り値)
```

　たとえば、`raw_df`の`gender`列の値が`"female"`なら1、それ以外なら0とし、その結果を`female`列として追加するコードは以下の通り。同値を意味する演算子が`=`でなく、`==`であることに注意すること（`=`は`<-`と同じ代入演算子であるが、Rでは代入演算子として`=`より`<-`の使用を推奨している）。

```{r}
mutate(raw_df, 
       female = if_else(gender == "female", 1, 0))
```

　`mutate()`は指定された列に対して何らかの処理を行い、その結果を新しい列として追加するか、上書きする関数である。この`mutate()`関数の第1引数もデータであるため、以下のようにパイプ演算子を使うこともできる。

```{r}
raw_df |>
  mutate(female = if_else(gender == "female", 1, 0))
```

　また、`mutate()`内には複数のコードを書くのもできる。`voted2000`列から`voted2006`列までそれぞれの値が`"yes"`であれば、1を、それ以外の場合は0にリコーディングしてみよう。

```{r}
raw_df |>
  mutate(female    = if_else(gender    == "female", 1, 0),
         voted2000 = if_else(voted2000 == "yes", 1, 0),
         voted2002 = if_else(voted2002 == "yes", 1, 0),
         voted2004 = if_else(voted2004 == "yes", 1, 0),
         voted2006 = if_else(voted2006 == "yes", 1, 0))
```

　また、パイプ演算子は2つ以上使うこともできる。たとえば、`rename()`を使って`gender`列を`female`に変更し、`mutate()`でリコーディングを行う場合、以下のように書く。これは`raw_df`を使って`rename()`の処理を行い、その結果を`mutate()`関数のデータとして渡すことを意味する。

```{r}
raw_df |>
  rename(female = gender) |>
  mutate(female    = if_else(female    == "female", 1, 0),
         voted2000 = if_else(voted2000 == "yes", 1, 0),
         voted2002 = if_else(voted2002 == "yes", 1, 0),
         voted2004 = if_else(voted2004 == "yes", 1, 0),
         voted2006 = if_else(voted2006 == "yes", 1, 0))
```

　以上のコードはデータを加工し、その結果を**出力するだけ**であって、その結果を保存しない。

```{r}
raw_df
```

　このように頑張ってデータを加工したもののその結果が全く反映されていない。加工したデータを引き続き使っていくためには、加工結果を作業環境内に保存する必要がある。作業環境内にオブジェクトを保存するためには代入演算子（`<-`）を使い、名前を付けて作業空間内に保存する（ファイルとして保存されるわけではない）必要がある。今回は加工の結果を`df`という名で保存する。`raw_df`に上書きしても問題はないが、生データはとりあえず作業空間内に残しておくことを推奨する（Rに慣れれば上書きしても良い）。

```{r}
df <- raw_df |>
  rename(female = gender) |>
  mutate(female    = if_else(female    == "female", 1, 0),
         voted2000 = if_else(voted2000 == "yes", 1, 0),
         voted2002 = if_else(voted2002 == "yes", 1, 0),
         voted2004 = if_else(voted2004 == "yes", 1, 0),
         voted2006 = if_else(voted2006 == "yes", 1, 0))

df
```

　ちなみに、`across()`関数とラムダ式（無名関数）を組み合わせると以上のコードを効率化することもできる。`across()`は強力な関数だが、初心者にはやや難しいかも知れない。詳細は『私たちのR』の[第13.1章](https://www.jaysong.net/RBook/datahandling2.html#handling2-summarise)を参照されたい。

```{r}
#| eval: false
df <- raw_df |>
  rename(female = gender) |>
  mutate(female = if_else(female == "female", 1, 0),
         across(starts_with("voted"), ~if_else(.x == "yes", 1, 0)))
```

## 記述統計量

　記述統計量の計算には{summarytools}の`descr()`関数が便利だ。`descr(データ名)`を入力するだけで各変数の記述統計量が出力される。実際にやってみると分かるが、情報量がかなり多い。しかし、実際の論文では各変数の歪度や尖度まで報告することはあまりないだろう。ここでは`stats`引数を追加して、論文などでよく使う平均値（`"mean"`）、標準偏差（`"sd"`）、最小値（`"min"`）、最大値（`"max"`）、有効ケース数（`"n.valid"`）のみ出力する。

```{r}
df |>
  descr(stats = c("mean", "sd", "min", "max", "n.valid"))
```

　ただし、`descr()`を使うと数値型（numeric）変数の記述統計量のみ表示される。`df`だと、`treatment`列は文字型（character）であるため、表示されない[^data-type]。各グループがサンプルの何割かを計算するためには、`treatment`変数をダミー変数へ変換する必要がある。ダミー変数の作成は面倒な作業であるが、{fastDummies}パッケージの`dummy_cols()`を使えば簡単にできる。`dummy_cols()`の中には`select_columns = "ダミー化する列名"`を入れれば、当該変数をダミー変数へ変換し、新しい列として追加してくれる。それでは`treatment`列をダミー化&追加し、その結果を`df`に上書きしてみよう。

[^data-type]: 変数のデータ型はデータを出力する際、列名の下段に表示される。`<chr>`は文字型、`<dbl>`と`<int>`は数値型、`<fct>`はfactor型である。他にもいくつかのデータ型がある。詳細は『私たちのR』の[第8章](https://www.jaysong.net/RBook/datatype.html)を参照すること。

```{r}
df <- df |>
  dummy_cols(select_columns = "treatment")

df
```

　画面には表示されないが、出力結果の下段を見ると`treatment_`で始まるいくつかの変数が追加されたことが分かる。ここでは`"tretmant"`で始まる列のみを抽出つして確認してみよう。

```{r}
df |>
  select(starts_with("treatment"))
```

　`select()`関数内には抽出する列名を入力するだけで良い。たとえば、`female`と`yob`列を抽出するなら`select(female, yob)`である。また、`female`**から**`voted2006`**まで**の意味で`female:voted2006`のような書き方もできる。他にも上の例のように`starts_with()`や`ends_with()`、`contain()`を使って特定の文字列で始まる（で終わる、を含む）列を指定することもできる。一部の列を除外する場合は変数名の前に`!`か`-`を付ける。

　とにかく、問題なくダミー化されていることが分かる。もう一度記述統計量を出してみよう。`descr()`は仕様上、出力される変数の順番はアルファベット順になるが、ここでは元の順番を維持するために`order = "p"`を追加する。また、通常の記述統計表が、先ほど見たものとは違って、各行が変数を、列は記述統計量を表す場合が多い。このように行と列を交換するためには`transpose = TRUE`を追加する[^descr-rmarkdown]。

[^descr-rmarkdown]: RMarkdown内に埋め込むなら更に`style = "rmarkdown"`を追加してみよう。ただし、Chunkオプションに`results = "asis"`（Quartoなら`#| results: "asis"`）を付けること。

```{r}
#| results: "asis"
df |>
  descr(stats = c("mean", "sd", "min", "max", "n.valid"),
        order = "p", transpose = TRUE, headings = FALSE)
```

　他にも以下のように`dfSummary()`関数を使えば、綺麗な表としてまとめてくれる。しかも文字型、factor型変数の場合も度数分布表を作成してくれるので非常に便利だ。これも{summarytools}パッケージに含まれた機能なので、別途、パッケージを読み込む必要はない。

```{r}
df |>
  select(-starts_with("treatment_")) |>
  dfSummary(headings = FALSE) |> 
  print(method = "render", round.digits = 3)
```

## バランスチェック

## 処置効果の確認

### グループごとの応答変数の平均値

　処置効果を確認するためには各グループごとの応答変数（ここでは`voted2006`）の平均値を計算し、処置群の平均値から統制群の平均値を引く必要がある。まずは、特定の変数の平均値を計算する方法について紹介する。データ内にある特定の変数の平均値を計算するためには`summarise()`関数内に平均値を求める`mean()`関数を入れる。たとえば、`df`の`voted2006`の平均値を計算するコードは以下の通りである。

```{r}
df |>
  summarise(mean(voted2006, na.rm = TRUE))
```

　`na.rm = TRUE`は「欠損値があれば、それを除外する」を意味し、指定されていない場合（=既定値）は`FALSE`になる。今回は欠損値がないものの、念の為に入れておく。

　出力結果を見ると、平均値が表示される列の名前が```` `mean(voted2006, na.rm = TRUE)` ````となっており、非常に見にくい。この場合、以下のように`mean()`の前に出力される列名を予め指定することもできる。

```{r}
df |>
  # voted2006の平均値が表示される列名を Outcome にする。
  summarise(Outcome = mean(voted2006, na.rm = TRUE))
```

　我々が知りたいのは`voted2006`の平均値でなく、**グループごと**の平均値だろう。被験者がどのグループに属しているかわ示す変数は`treatment`であるが、`summarise()`にデータを渡す前に`group_by()`変数を使うと、グループごとに計算を行い、その結果を返す。

```{r}
df |>
  group_by(treatment) |>
  summarise(Outcome = mean(voted2006, na.rm = TRUE))
```

　`group_by()`内でも`=`演算子を使うと、グループ名が出力される列名を変更することができる。

```{r}
df |>
  # グループ名が表示される列名を Group にする。
  group_by(Groups = treatment) |>
  summarise(Outcome = mean(voted2006, na.rm = TRUE))
```

　ここで一つ注目したいのが、グループの表示順番である。変数のデータ型が文字型だと（Rコンソール上で`class(df$treatment)`を入力するか、`df`の出力画面で`treatment`の下に`<chr>`と表示されていることで確認できる）、今のようにアルファベット順で表示される。しかし、統制群は最初か最後に来るのが通例である。この順番をアルファベット順でなく、任意の順番にするためには`treatment`変数をfactor型変数へ変換する必要がある。Factor型は「順序付きの文字型変数」だと理解しても良い[^factor-numeric]。列の追加・上書き（今回は`treatment`列の上書き）の処理が必要なので`mutate()`関数を使う。変数をfactor型に変換する関数は`factor()`関数で、第1引数としてはfactor型へ変換する変数名を指定する。第2引数は`levels`であり、出力したい順番の文字型ベクトルを指定する。**スペルミス**に注意すること。

[^factor-numeric]: 中身が1、2、3、...であってもfactor型であれば1、2、3、...は数字でなく文字として認識される。

```{r}
df |>
  mutate(treatment = factor(treatment,
                            levels = c("Control", "Civic Duty",
                                       "Self", "Neighbors", "Hawthorne")))
```

　`treatment`列名の下が`<fct>`となっていることが分かる。これは`treatment`列のデータ型がfactor型であることを意味する。問題なく動くことが確認できたので、`df`を上書きしよう。

```{r}
df <- df |>
  mutate(treatment = factor(treatment,
                            levels = c("Control", "Civic Duty",
                                       "Self", "Neighbors", "Hawthorne")))
```

　それでは、改めてグループごとの`voted2006`の平均値を計算してみよう。今回は計算結果を`out_mean_df`という名のオブジェクトとして格納する。

```{r}
out_mean_df <- df |>
  group_by(Groups = treatment) |>
  summarise(Outcome = mean(voted2006, na.rm = TRUE))

out_mean_df
```

　今回は統制群は最初に出力されていることが確認できる。

　それではこの結果をグラフとして示してみよう。作図には{ggplot2}パッケージを使う。まずは`out_mean_df`を`ggplot()`関数に渡す。`ggplot()`関数以降は、`+`演算子を使ってレイヤーを足していくこととなる。棒グラフのレイヤーは`geom_bar()`関数であり、その中に`aes()`関数を入れる。`aes()`の中には棒グラフの作図に必要な情報を入れる必要がある（これを**マッピング**（mapping）と呼ぶ）。棒グラフを作成するために必要な最低限の情報とは各棒の横軸上の位置（`x`）と棒の高さ（`y`）だ。今回は横軸がグループ名、縦軸が平均値となる棒グラフを作る。`aes()`外側には`stat = "identity"`を忘れずに付けること。

```{r fig-intro-bar-1}
out_mean_df |>
  ggplot() +
  geom_bar(aes(x = Groups, y = Outcome), stat = "identity")
```

　続いて、このグラフの見た目を調整してみよう。

```{r fig-intro-bar-2}
out_mean_df |>
  ggplot() +
  geom_bar(aes(x = Groups, y = Outcome), stat = "identity") +
  # 縦軸（y軸）のラベルを変更する
  labs(y = "Mean(Outcome)") +
  # grayテーマ（デフォルトのテーマ）を使用し、フォントサイズは14
  theme_gray(base_size = 14)
```

　また、`geom_label()`レイヤーを足すと、棒の上にラベルを付けることもできる。ラベルに必要な情報は各ラベルの横軸上の位置（`x`）、縦軸上の位置（`y`）、ラベルの表示内容（`label`）だ。今回のラベルは平均値の具体的な数値を入れてみよう。

```{r fig-intro-bar-3}
out_mean_df |>
  ggplot() +
  geom_bar(aes(x = Groups, y = Outcome), stat = "identity") +
  geom_label(aes(x = Groups, y = Outcome, label = Outcome)) +
  labs(y = "Mean(Outcome)") +
  theme_gray(base_size = 14)
```

　小数点が長すぎるので3桁まで表示としよう。ここでは`sprintf()`を使用する。使い方が簡単とは言えないが、覚える必要はなく、必要な時にググるか、本資料のコードをコピペすれば良い[^sprintf]。

[^sprintf]: もっと使いやすい`round()`があるが、`round()`の場合、丸めた結果が1.100なら1.1としか表記されない。表示される桁数を固定するためには`sprintf()`を使う。

```{r fig-intro-bar-4}
out_mean_df |>
  ggplot() +
  geom_bar(aes(x = Groups, y = Outcome), stat = "identity") +
  # 2桁までなら %.3f を %.2f に変更
  geom_label(aes(x = Groups, y = Outcome, label = sprintf("%.3f", Outcome))) +
  labs(y = "Mean(Outcome)") +
  theme_gray(base_size = 14)
```

　これで可視化ができた。ただし、以上のコードには改善の余地がある。`geom_bar()`と`geom_label()`内の`aes()`関数に注目して欲しい。よく見ると`x`と`y`と同じだろう。`geom_*()`が共有するマッピングがあれば、`ggplot()`内で指定することでコードを効率化することもできる。

```{r fig-intro-bar-5}
out_mean_df |>
  ggplot(aes(x = Groups, y = Outcome)) +
  geom_bar(stat = "identity") +
  geom_label(aes(label = sprintf("%.3f", Outcome))) +
  labs(y = "Mean(Outcome)") +
  theme_gray(base_size = 14)
```

### 統計的推定（単回帰分析）

　これまでの作業はグループごとの応答変数の平均値であって、処置効果ではない。処置効果を計算するためには処置群の平均値から統制群の平均値を引く必要がある。たとえば、Civic Dutyはがき群の平均値は約`r round(out_mean_df$Outcome[2], 3)`、統制群のそれは`r round(out_mean_df$Outcome[1], 3)`であるため、Civic Dutyはがきの処置効果は約`r round(out_mean_df$Outcome[2] - out_mean_df$Outcome[1], 3)`である。しかし、これを各グループごとに計算することは面倒だし、何よりも得られた値が**点推定値**だという限界がある。得られた処置効果の不確実性は計算できない。

　ここで有効なのが線形回帰分析である。回帰分析を行うことで処置効果の点推定値のみならず、不確実性の指標である標準誤差も計算され、区間推定や統計的仮説検定も可能となる。線形回帰分析の関数は`lm()`だ。第1引数としては回帰式であり、`応答変数 ~ 説明変数`と表記する。第2引数は`data`であり、回帰式で指定した変数が入っているデータ名を指定する。回帰分析の結果は名前を付けてオブジェクトとして格納し、`summary()`関数を使うと、詳細が確認できる。

```{r}
fit1 <- lm(voted2006 ~ treatment, data = df)

summary(fit1)
```

　ちなみに、これもパイプ演算子を使うことができる。ただし、第1引数として渡すパイプ演算子の特徴上、そのまま使うことはできない。なぜなら`lm()`関数の第1引数はデータでなく、回帰式（formula型）だから。この場合はプレースホルダー（place holder）を指定する必要がある。パイプ前のオブジェクトが入る位置を任意に指定することであり、`_`を使う。`%>%`演算子を使う場合は`_`でなく、`.`を使う。上記のコードと以下のコードは同じコードとなる。プレースホルダーは自分が使うパイプ演算子によって使い分けること。

```{r}
#| eval: false
fit1 <- df |> # |> パイプを使う場合
  lm(voted2006 ~ treatment, data = _)

fit1 <- df %>% # %>% パイプを使う場合
  lm(voted2006 ~ treatment, data = .)
```

　Factor型、または文字型変数が説明変数の場合、自動的にダミー変数として処理され、Factor型の場合、最初の水準（ここでは`"Control"`）がベースカテゴリとなる。説明変数が文字型ならアルファベット順で最初の水準がベースカテゴリとなり、今回の例だと`"Civic Duty"`がベースカテゴリとなる。処置効果は「統制群に比べて〜」が重要となるので、数値型以外の説明変数は予めfactor化しておいた方が望ましい。

　Civic Dutyの推定値は約`r sprintf("%.3f", coef(fit1)[2])`であり、これは統制群に比べ、Civic Duty群の`voted2006`の平均値は約`r sprintf("%.3f", coef(fit1)[2])`高いことを意味する。応答変数が0、1であるため、これを割合（=投票率）で換算すると、約`r sprintf("%.1f", coef(fit1)[2] * 100)`%p高いことを意味する。つまり、Civic Dutyのはがきをもらった被験者はそうでない被験者に比べて投票率が約`r sprintf("%.1f", coef(fit1)[2] * 100)`%p高いことを意味する。他の推定値も同じやり方で解釈すれば良い。

　それではこれらの処置効果が**統計的に有意**なものかを確認してみよう。統計的有意か否かを判定するためには有意と非有意の境界線が必要である、これは通常、**有意水準**（significance level; $\alpha$）と呼ばれる。この有意水準は分析者が決めるものであるが、社会科学で広く使われる基準は$\alpha = 0.05$、つまり5%だ。分析結果の画面には`Pr(>|t|)`列が表示されているが、これが$p$値と呼ばれるもので、これが0.05を下回る場合、統計的に有意と判定する。もし、$\alpha = 0.1$を採用するなら、$p < 0.1$の場合において統計的に有意と判定する。Civic Dutyの$p$値は5.85e-12であり、これは$5.75 \times 10^{-12}$を意味する。$10^{-1}$は0.1、$10^{-2}$は0.01であることを考えると非常に小さい数値であり、統計的に有意であると考えられる。また、$p$値が一定値以下であれば`< 2e-16`と表示される。4つの処置群において処置効果は統計的に有意であると判定できよう。

　続いて、この結果を可視化してみよう。ここでも{ggplot2}パッケージを使って可視化をするが、{ggplot2}で使用可能なオブジェクトは表形式のデータである。Rコンソール上で`class(オブジェクト名)`を入力すると、データのクラスが出力されるが、このクラスに`"data.frame"`があれば、{ggplot2}で使用できる。たとえば、`fit1`オブジェクトのクラスは`"lm"`であるため、そのまま{ggplot2}で使うことはできない。

```{r}
class(fit1)
```

　推定結果を表形式に変換するためには{broom}パッケージの`tidy()`関数が便利だ。使い方は簡単で`tidy()`内に回帰分析の推定結果が格納されたオブジェクトを入れるだけである。ただし、デフォルトの設定では95%信頼区間が表示されないため、中には`conf.int = TRUE`を追加しておく必要がある。

```{r}
# 90%信頼区間を使うのであれば conf.int = 0.9 を追加（デフォルトは0.95）
fit1_coef <- tidy(fit1, conf.int = TRUE)

fit1_coef

class(fit1_coef)
```

　`fit1_coef`のクラスに`"data.frame"`が含まれているので、これを使って作図することができる。

　作図する前に、`fit1_coef`の加工しておきたい。それぞれの係数（`estimate`列）は処置効果を表しているが、切片（`"(Intercept)"`）の推定値は処置効果とは無関係である。したがって、予め切片の行を除外しておきたい。特定の行を残したり、除外する関数は`filter()`である。今回は`term`列の値が`"(Intercept)"`**ではない**行を残したいので、同値演算子（`==`）の否定を意味する`!=`演算子を使用する。

```{r}
fit1_coef <- fit1_coef |>
  filter(term != "(Intercept)")

fit1_coef
```

　それでは作図に入ろう。処置効果を示す場合は、点推定値以外にもその不確実性を示すのは一般的である。不確実性の指標として幅広く使われるのは標準誤差（standard error; 標準**偏差**ではない）であるが、可視化の際にはこの標準誤差に基づき計算した信頼区間を示すのが一般的だ。有意水準が5%であれば、95%信頼区間を示し、10%なら90%信頼区間を用いる。

　点と区間を同時に示すプロットがpoint-rangeプロットであり、{ggplot2}では`geom_pointrange()`レイヤーを使う。必要な情報はpoint-rangeの横軸上の位置（`x`）、点の縦軸上の位置（`y`）、区間の上限（`ymax`）と下限（`ymin`）である。これらの情報は全て`fit1_coef`に入っているため、`fit1_coef`をそのまま`ggplot()`関数に渡して作図することができる。

```{r fig-intro-pointrange-1}
#| fig-height: 3.5
fit1_coef |>
  ggplot() +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high))
```

　それでは図をカスタマイズしてみよう。図内の様々なラベルを修正する`labs()`レイヤーでラベルを修正する。テーマはデフォルトの`theme_gray()`の代わりに白黒テーマ（`theme_bw()`）を使用し、フォントサイズは12とする。また、y = 0の水平線を追加する。95%信頼区間内に0が含まれる場合、「5%水準で統計的に有意でない」と判断できる。水平線を描くには`geom_hline()`レイヤーを追加し、`yintercept = 0`を指定することで、0のところに水平線が描ける。

```{r fig-intro-pointrange-2}
#| fig-height: 3.5
fit1_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12)
```

　まだ気になる点がある。それは横軸の目盛りラベルに`treatment`という不要な情報がある点だ。これは作図の時点で修正することも可能だが、まずは`df`の`term`変数の値を修正する方法を紹介する。変数の値を修正する時には`recode()`関数を使用する。第1引数はリコーディングする変数名であり、引き続き`"元の値" = "新しい値"`を指定すれば良い。**スペルミスに注意**すること。

```{r}
fit1_coef <- fit1_coef |>
  mutate(term = recode(term,
                       "treatmentCivic Duty" = "Civic Duty",
                       "treatmentHawthorne"  = "Hawthorne",
                       "treatmentNeighbors"  = "Neighbors",
                       "treatmentSelf"       = "Self"))

fit1_coef
```

　以上の作業は`term`列の各値から`"treatment"`文字を`""`に置換することなので、文字列を置換する関数である`str_replace()`を使えば、より短くすることができる。

```{r}
#| eval: false
fit1_coef <- fit1_coef |>
  mutate(term = str_replace(term, "treatment", ""))
```

　`fit1_coef`も修正できたので、 @fig-intro-pointrange-2 と同じコードでもう一度作図してみよう。

```{r fig-intro-pointrange-3}
#| fig-height: 3.5
fit1_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12)
```

　最後に横軸の順番を修正してみよう。`fit1_coef`の`term`列は文字型変数であるため、アルファベット順になる。これを`df`の`treatment`列と同様、Civic Duty、Self、Neighbors、Hawthorneの順にしたい。この場合`fit1_coef`の`term`列をfactor化すれば良い。`factor()`関数を使っても良いが、ここではまた便利な技を紹介しよう。それは`fct_inorder()`関数だ。これは表示されている順番をfactorの順番とする関数だ。実際、`fit1_coef`の中身を見ると、表示順番はCivic Duty、Self、Neighbors、Hawthorneだ。非常に嬉しい状況なので、`fct_inorder()`を使ってみよう。

```{r}
fit1_coef <- fit1_coef |>
  mutate(term = fct_inorder(term))

fit1_coef
```

　それでは、 @fig-intro-pointrange-3 と同じコードでもう一度作図してみよう。

```{r fig-intro-pointrange-4}
#| fig-height: 3.5
fit1_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12)
```

　これで処置効果の可視化もバッチリだ。

### 多重比較の問題

　グループが2つ、つまり統制群と統制群のみが存在する場合、我々が比較を行う回数は1回のみである（統制群 - 処置群）。しかし、今回のデータの場合、処置群は4つである。これは比較を4回行うことを意味する。具体的には「統制群 - 処置群1」、「統制群 - 処置群2」、「統制群 - 処置群3」、「統制群 - 処置群4」だ。比較を繰り返すほど、統計的に有意な結果が得られる可能性は高い。極端な話、1000回程度検定を繰り返せば、本当は効果がなくても**たまたま**統計的に有意な結果が何回かは得られるだろう。これが多重検定（multiple testing）の問題である。したがって、比較の回数が多くなるにつれ、統計的有意性検定にも何らかのペナルティーを課す必要がある。

　多重比較におけるペナルティーの付け方はいくつかあるが、ここでは最も保守的な（=研究者にとって都合の悪い）補正法であるボンフェローニ補正（Bonferroni correction）を紹介する。これは非常に単純で、$p$値や信頼区間を計算する際、「統計的有意」と判定されるハードルを上げる方法である。予め決めておいた有意水準（$\alpha$）が0.05で、比較の回数が4回であれば、$p$値が$0.05 \times \frac{1}{4} = 0.0125$を下回る場合において「5%水準で有意である」と判定する。信頼区間でいえば通常の95%信頼区間（1 - 0.05）でなく、98.75%信頼区間（1 - 0.0125）を使うこととなる。この結果、統計的に有意な結果が得られたら「1.25%水準で〜」と解釈するのではなく、「5%水準で〜」と解釈する必要がある。

　95%以外の信頼区間を求めるのは簡単で、`tidy()`関数内に`conf.level`を修正すれば良い。指定されていない場合はデフォルトで0.95が割り当てられているが、これを0.9875と修正する。

```{r}
fit1_coef <- tidy(fit1, conf.int = TRUE, conf.level = 0.9875)

fit1_coef
```

```{r}
fit1_coef <- fit1_coef |>
  slice(2:5)

fit1_coef
```

```{r}
fit1_coef <- fit1_coef |>
  mutate(term = recode(term,
                       "treatmentCivic Duty" = "Civic Duty",
                       "treatmentHawthorne"  = "Hawthorne",
                       "treatmentNeighbors"  = "Neighbors",
                       "treatmentSelf"       = "Self"),
         term = fct_inorder(term))

fit1_coef
```

```{r fig-intro-pointrange-5}
#| fig-height: 3.5
fit1_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "Treatments", 
       y = "Average Treatment Effects (w/ 98.75% CI)") +
  theme_bw(base_size = 12)
```

### 統計的推定（重回帰分析）

```{r}
fit2 <-lm(voted2006 ~ treatment + female + yob + hh_size +
            voted2000 + voted2002 + voted2004, data = df)

summary(fit2)
```

```{r}
modelsummary(fit2)
```

```{r}
modelsummary(list("w/o Covariates" = fit1, "w/ Covariates" = fit2))
```

```{r}
modelsummary(list("w/o Covariates" = fit1, "w/ Covariates" = fit2),
             estimate  = "{estimate} ({std.error})",
             statistic = NULL)
```

```{r}
modelsummary(list("w/o Covariates" = fit1, "w/ Covariates" = fit2),
             estimate  = "{estimate} ({std.error})",
             statistic = NULL,
             coef_rename = c("treatmentCivic Duty" = "Civic Duty",
                             "treatmentSelf"       = "Self",
                             "treatmentNeighbors"  = "Neighbors",
                             "treatmentHawthorne"  = "Hawthorne",
                             "female"              = "Female",
                             "yob"                 = "Year of Birth",
                             "hh_size"             = "Household Size",
                             "voted2000"           = "Voted (2000)",
                             "voted2002"           = "Voted (2002)",
                             "voted2004"           = "Voted (2004)"))
```

## 番外編

```{r}
fit2_coef <- tidy(fit1, conf.int = TRUE, conf.level = 0.9875)

fit2_coef <- fit2_coef |>
  slice(2:5) |>
  mutate(term = recode(term,
                       "treatmentCivic Duty" = "Civic Duty",
                       "treatmentHawthorne"  = "Hawthorne",
                       "treatmentNeighbors"  = "Neighbors",
                       "treatmentSelf"       = "Self"),
         term = fct_inorder(term))

fit2_coef
```

```{r}
bind_rows(list("Model 1" = fit1_coef, 
               "Model 2" = fit2_coef))
```

```{r}
bind_rows(list("Model 1" = fit1_coef, 
               "Model 2" = fit2_coef),
          .id = "Model")
```

```{r}
fit_coef <- bind_rows(list("Model 1" = fit1_coef, 
                           "Model 2" = fit2_coef),
                      .id = "Model")
```

```{r fig-intro-pointrange-6}
#| fig-height: 3.5
fit_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  facet_wrap(~ Model) +
  theme_bw(base_size = 12)
```

```{r fig-intro-pointrange-7}
#| fig-height: 3.5
fit_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high,
                      color = Model)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12)
```

```{r fig-intro-pointrange-8}
#| fig-height: 3.5
fit_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high,
                      color = Model)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12)
```

```{r fig-intro-pointrange-9}
#| fig-height: 3.5
fit_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high,
                      color = Model),
                  position = position_dodge2(1/2)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12)
```

```{r fig-intro-pointrange-10}
#| fig-height: 3.5
fit_coef |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = term, y = estimate,
                      ymin = conf.low, ymax = conf.high,
                      color = Model),
                  position = position_dodge2(1/2)) +
  labs(x = "Treatments", y = "Average Treatment Effects") +
  theme_bw(base_size = 12) +
  theme(legend.position = "bottom")
```